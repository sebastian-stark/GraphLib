<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Library GraphLib: GraphLib::Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Library GraphLib
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_graph_lib.html">GraphLib</a></li><li class="navelem"><a class="el" href="class_graph_lib_1_1_graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph_lib_1_1_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GraphLib::Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="graph_8h_source.html">graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca7f98e3f4acd61ca612750ffb64543f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#aca7f98e3f4acd61ca612750ffb64543f">Graph</a> (const std::function&lt; double(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;, const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt; <a class="el" href="class_graph_lib_1_1_graph.html#a90a90d7364f268d51f05dffd002c3ef7">metric</a>)</td></tr>
<tr class="separator:aca7f98e3f4acd61ca612750ffb64543f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130b4b82cca0ca986c220d2532bcc479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a130b4b82cca0ca986c220d2532bcc479">set_metric</a> (const std::function&lt; double(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;, const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt; <a class="el" href="class_graph_lib_1_1_graph.html#a90a90d7364f268d51f05dffd002c3ef7">metric</a>)</td></tr>
<tr class="separator:a130b4b82cca0ca986c220d2532bcc479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb13a8c4f1d861dcd62aa72cb2b505b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#aeb13a8c4f1d861dcd62aa72cb2b505b1">add_edge</a> (const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> node_1, const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> node_2, std::vector&lt; <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &gt; coordinates, <a class="el" href="namespace_graph_lib.html#a5bf5516c3b23da8f7af1226afab50a5a">Direction</a> direction=Direction::both)</td></tr>
<tr class="separator:aeb13a8c4f1d861dcd62aa72cb2b505b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e592bff23dd764067af391d91fd59b0"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="class_graph_lib_1_1_edge.html">Edge</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a3e592bff23dd764067af391d91fd59b0">begin</a> ()</td></tr>
<tr class="separator:a3e592bff23dd764067af391d91fd59b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f23adba10adb5712c0bde84d24d154e"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="class_graph_lib_1_1_edge.html">Edge</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a1f23adba10adb5712c0bde84d24d154e">end</a> ()</td></tr>
<tr class="separator:a1f23adba10adb5712c0bde84d24d154e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac619f84a3fe16cd25b4e5279d215cfd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#ac619f84a3fe16cd25b4e5279d215cfd0">remove_flagged_edges</a> ()</td></tr>
<tr class="separator:ac619f84a3fe16cd25b4e5279d215cfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10505c386680bdb79efa0dc5b0f7f5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#af10505c386680bdb79efa0dc5b0f7f5d">write_svg</a> (const std::string file_name, const std::function&lt; <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt; &amp;coordinate_transform=[](const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;p) -&gt; <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>{return p;}, const bool highlight_flagged_edges=false, const double width=1000.0) const</td></tr>
<tr class="separator:af10505c386680bdb79efa0dc5b0f7f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc2fe03dcb9ad88dd5dbee1d8fb17c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#accc2fe03dcb9ad88dd5dbee1d8fb17c1">read_graph_from_osm</a> (const std::string file_name, const std::function&lt; bool(const osmium::Way &amp;)&gt; &amp;include_way, const std::function&lt; bool(const osmium::NodeRef &amp;)&gt; &amp;include_node, const bool remove_dead_ends=false)</td></tr>
<tr class="separator:accc2fe03dcb9ad88dd5dbee1d8fb17c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf1e69b32cd4644bc7291337be9d8a6"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; const <a class="el" href="class_graph_lib_1_1_edge.html">Edge</a> *, <a class="el" href="namespace_graph_lib.html#a5bf5516c3b23da8f7af1226afab50a5a">Direction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#accf1e69b32cd4644bc7291337be9d8a6">compute_shortest_path</a> (const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> node_1, const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> node_2) const</td></tr>
<tr class="separator:accf1e69b32cd4644bc7291337be9d8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648d1bfbd8a9c70b41be6c4bf846ad6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a648d1bfbd8a9c70b41be6c4bf846ad6a">get_closest_node</a> (const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> p, const std::set&lt; <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> &gt; nodes_ignore=std::set&lt; <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> &gt;()) const</td></tr>
<tr class="separator:a648d1bfbd8a9c70b41be6c4bf846ad6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635d70d0608d1f1293758db509707832"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a635d70d0608d1f1293758db509707832">get_degree</a> (const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> node) const</td></tr>
<tr class="separator:a635d70d0608d1f1293758db509707832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e38ef4ff5888cec1b03b250e102bb52"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a1e38ef4ff5888cec1b03b250e102bb52">get_n_nodes</a> () const</td></tr>
<tr class="separator:a1e38ef4ff5888cec1b03b250e102bb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4def7d2dad543ac2d347be43d7c5a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a57b4def7d2dad543ac2d347be43d7c5a">get_n_edges</a> () const</td></tr>
<tr class="separator:a57b4def7d2dad543ac2d347be43d7c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af1d98d86195763d4252d2bbbc2489f90"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="class_graph_lib_1_1_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#af1d98d86195763d4252d2bbbc2489f90">edges</a></td></tr>
<tr class="separator:af1d98d86195763d4252d2bbbc2489f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51721d9af94391bbc63332404867848"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>, std::set&lt; <a class="el" href="class_graph_lib_1_1_edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#ad51721d9af94391bbc63332404867848">nodes</a></td></tr>
<tr class="separator:ad51721d9af94391bbc63332404867848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a90d7364f268d51f05dffd002c3ef7"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;, const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph_lib_1_1_graph.html#a90a90d7364f268d51f05dffd002c3ef7">metric</a></td></tr>
<tr class="separator:a90a90d7364f268d51f05dffd002c3ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class managing a graph, with each edge being associated with geometrical information about its shape. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aca7f98e3f4acd61ca612750ffb64543f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7f98e3f4acd61ca612750ffb64543f">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphLib::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;, const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>The metric to be used to determine distances along edges of the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb13a8c4f1d861dcd62aa72cb2b505b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb13a8c4f1d861dcd62aa72cb2b505b1">&#9670;&nbsp;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphLib::Graph::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;</td>
          <td class="paramname"><em>node_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;</td>
          <td class="paramname"><em>node_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &gt;&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_graph_lib.html#a5bf5516c3b23da8f7af1226afab50a5a">Direction</a>&#160;</td>
          <td class="paramname"><em>direction</em> = <code>Direction::both</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_1</td><td>the first node making up the edge</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_2</td><td>the second node making up the edge</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinates</td><td>the coordinates describing the geometry of the edge when going from <code>node_1</code> to <code>node_2</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>the direction of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e592bff23dd764067af391d91fd59b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e592bff23dd764067af391d91fd59b0">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_graph_lib_1_1_edge.html">Edge</a>&gt;::iterator GraphLib::Graph::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>begin iterator over the edges of the <a class="el" href="class_graph_lib_1_1_graph.html">Graph</a></p>
<dl class="section return"><dt>Returns</dt><dd>begin iterator </dd></dl>

</div>
</div>
<a id="accf1e69b32cd4644bc7291337be9d8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf1e69b32cd4644bc7291337be9d8a6">&#9670;&nbsp;</a></span>compute_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::pair&lt;const <a class="el" href="class_graph_lib_1_1_edge.html">Edge</a>*, <a class="el" href="namespace_graph_lib.html#a5bf5516c3b23da8f7af1226afab50a5a">Direction</a>&gt; &gt; GraphLib::Graph::compute_shortest_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;</td>
          <td class="paramname"><em>node_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;</td>
          <td class="paramname"><em>node_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function calculating shortest path between <code>node_1</code> and <code>node_2</code> based on Dijkstra's algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_1</td><td>Start node</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_2</td><td>End node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of pairs of edges and directions describing the shortest path from <code>node_1</code> to <code>node_2</code>. The list is ordered by the order of traversal of the edges when following the shortest path; and Direction::forward indicates that an edge is traversed from node 1 to node 2, while Direction::backward indicates than an edge is traversed from node 2 to node 1. </dd></dl>

</div>
</div>
<a id="a1f23adba10adb5712c0bde84d24d154e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f23adba10adb5712c0bde84d24d154e">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_graph_lib_1_1_edge.html">Edge</a>&gt;::iterator GraphLib::Graph::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>end iterator over the edges of the <a class="el" href="class_graph_lib_1_1_graph.html">Graph</a></p>
<dl class="section return"><dt>Returns</dt><dd>end iterator </dd></dl>

</div>
</div>
<a id="a648d1bfbd8a9c70b41be6c4bf846ad6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648d1bfbd8a9c70b41be6c4bf846ad6a">&#9670;&nbsp;</a></span>get_closest_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> GraphLib::Graph::get_closest_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes_ignore</em> = <code>std::set&lt;&#160;<a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the node closest to <code>p</code>, while ignoring all nodes stored in <code>p_ignore</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The coordinates of the point to which the closest node is to be found</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes_ignore</td><td>A set of nodes to be ignored during the search </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a635d70d0608d1f1293758db509707832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635d70d0608d1f1293758db509707832">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GraphLib::Graph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the degree of a node (not considering direction of edges)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>The node index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The degree of <code>node</code> </dd></dl>

</div>
</div>
<a id="a57b4def7d2dad543ac2d347be43d7c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4def7d2dad543ac2d347be43d7c5a">&#9670;&nbsp;</a></span>get_n_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GraphLib::Graph::get_n_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of edges involved in the graph </dd></dl>

</div>
</div>
<a id="a1e38ef4ff5888cec1b03b250e102bb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e38ef4ff5888cec1b03b250e102bb52">&#9670;&nbsp;</a></span>get_n_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GraphLib::Graph::get_n_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of nodes involved in the graph </dd></dl>

</div>
</div>
<a id="accc2fe03dcb9ad88dd5dbee1d8fb17c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc2fe03dcb9ad88dd5dbee1d8fb17c1">&#9670;&nbsp;</a></span>read_graph_from_osm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphLib::Graph::read_graph_from_osm </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const osmium::Way &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>include_way</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const osmium::NodeRef &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>include_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>remove_dead_ends</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the graph from an *.osm.pbf file (only way and node information of the given file is taken into account). The reading process will also "clean up" the graph, such that nodes with degree 2 are generally eliminated (the corresponding edges are joined).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>file (including path and extension)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_way</td><td>function deciding whether to take a way into consideration or to ignore it (if <code>true</code> is returned by the function, the way is taken into consideration)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">include_node</td><td>function deciding whether to take a node into consideration or to ignore it (if <code>true</code> is returned by the function, the node is taken into consideration)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_dead_ends</td><td>if <code>true</code>, all nodes with degree 1 are removed (together with the corresponding edges). I.e., no "dead ends" are kept in the graph</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Reading and processing *.osm.pdf files can take a very long time due to their size. So, the files are ideally clipped to the region really needed. The latter can be achieved e.g. by using the Osmium tool (command "osmium extract") </dd></dl>

</div>
</div>
<a id="ac619f84a3fe16cd25b4e5279d215cfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac619f84a3fe16cd25b4e5279d215cfd0">&#9670;&nbsp;</a></span>remove_flagged_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphLib::Graph::remove_flagged_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This removes all edges from the <a class="el" href="class_graph_lib_1_1_graph.html">Graph</a>, which have been flagged before. If one ends up with isolated nodes (i.e., nodes with degree 0), these nodes are removed from the graph as well.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_graph_lib_1_1_edge.html#a848b1216268d43a79dd1a0fcbae166e1">Edge::set_user_flag()</a>, <a class="el" href="class_graph_lib_1_1_edge.html#a42c2c76c3cf78be1ab318612cb5b05ce">Edge::reset_user_flag()</a>, <a class="el" href="class_graph_lib_1_1_edge.html#afc4a997a6f729101d8570f825bc7f387">Edge::get_user_flag()</a> </dd></dl>

</div>
</div>
<a id="a130b4b82cca0ca986c220d2532bcc479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130b4b82cca0ca986c220d2532bcc479">&#9670;&nbsp;</a></span>set_metric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphLib::Graph::set_metric </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;, const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the metric of the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metric</td><td>The new metric function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10505c386680bdb79efa0dc5b0f7f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10505c386680bdb79efa0dc5b0f7f5d">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GraphLib::Graph::write_svg </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinate_transform</em> = <code>[](const&#160;<a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>&#160;&amp;p)&#160;-&gt;&#160;<a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>{return&#160;p;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>highlight_flagged_edges</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>width</em> = <code>1000.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph to the specified svg file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>The file name of the svg file (including the extension)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordinate_transform</td><td>A transformation applied to the coordinates defining the geometry of the graph edges before writing the svg. If e.g. the coordinates of the graph edges represent longitude and latitude, this defines the projection to planar coordinates.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">highlight_flagged_edges</td><td>If <code>true</code>, flagged edges are drawn red</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the svg in px </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af1d98d86195763d4252d2bbbc2489f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d98d86195763d4252d2bbbc2489f90">&#9670;&nbsp;</a></span>edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="class_graph_lib_1_1_edge.html">Edge</a>&gt; GraphLib::Graph::edges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List containing the edges of the graph. </p>

</div>
</div>
<a id="a90a90d7364f268d51f05dffd002c3ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a90d7364f268d51f05dffd002c3ef7">&#9670;&nbsp;</a></span>metric</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;double(const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>&amp;, const <a class="el" href="namespace_graph_lib.html#aedce1a218e8997c889ed4a2e30ba23a9">coordinate_t</a>&amp;)&gt; GraphLib::Graph::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The metric used for the graph </p>

</div>
</div>
<a id="ad51721d9af94391bbc63332404867848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51721d9af94391bbc63332404867848">&#9670;&nbsp;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="namespace_graph_lib.html#a93d9cfaf86aae4dac4542492e675fec8">Node</a>, std::set&lt;<a class="el" href="class_graph_lib_1_1_edge.html">Edge</a>*&gt; &gt; GraphLib::Graph::nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between the nodes of the graph and a set of edges associated with each node. Using a map offers flexibility for adding new nodes/edges, removing nodes/edges and lookup of certain nodes. In particular, no assumption of a contiguous node numbering is necessary with this approach. However, it is of course not nearly as efficient (with regard to memory usage and computational cost of operations on the graph) as using vectors together with a contiguous node numbering starting from 0. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/sst/code/GraphLib/GraphLib/include/graph_lib/<a class="el" href="graph_8h_source.html">graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
